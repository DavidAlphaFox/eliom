<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title> Communication between the client and the server &amp;#182;</title><meta charset="utf8"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script src="/client.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js"></script></head><body><h1> Eliom's Reference manual</h1><h2><a href="/eliom/6.2/manual/intro.html" class="ocsimore_phrasing_link">Introduction</a></h2><h2>Server-side programming</h2><h3>Services</h3><h4><a href="/eliom/6.2/manual/server-services.html" class="ocsimore_phrasing_link">The different types of services</a></h4><h4><a href="/eliom/6.2/manual/server-params.html" class="ocsimore_phrasing_link">Typing service parameters</a></h4><h4><a href="/eliom/6.2/manual/server-outputs.html" class="ocsimore_phrasing_link">Service handlers</a></h4><h4><a href="/eliom/6.2/manual/server-links.html" class="ocsimore_phrasing_link">Creating links and forms</a></h4><h3><a href="/eliom/6.2/manual/server-state.html" class="ocsimore_phrasing_link">Sessions and server side state</a></h3><h3><a href="/eliom/6.2/manual/server-security.html" class="ocsimore_phrasing_link">Security</a></h3><h2>Client-server programming</h2><h3><a href="/eliom/6.2/manual/clientserver-applications.html" class="ocsimore_phrasing_link">Eliom applications</a></h3><h3><a href="/eliom/6.2/manual/clientserver-html.html" class="ocsimore_phrasing_link">Generating HTML</a></h3><h3><a href="/eliom/6.2/manual/clientserver-communication.html" class="ocsimore_phrasing_link">Communication</a></h3><h3><a href="/eliom/6.2/manual/clientserver-services.html" class="ocsimore_phrasing_link">Client-side services</a></h3><h3><a href="/eliom/6.2/manual/clientserver-react.html" class="ocsimore_phrasing_link">Shared reactive programming</a></h3><h3><a href="/eliom/6.2/manual/clientserver-cache.html" class="ocsimore_phrasing_link">Caching data and off-line applications</a></h3><h3><a href="/eliom/6.2/manual/clientserver-wrapping.html" class="ocsimore_phrasing_link">Custom wrapping</a></h3><h2>Workflows</h2><h3><a href="/eliom/6.2/manual/workflow-distillery.html" class="ocsimore_phrasing_link">Distillery</a></h3><h3><a href="/eliom/6.2/manual/mobile-apps.html" class="ocsimore_phrasing_link">Mobile apps</a></h3><h3><a href="/eliom/6.2/manual/workflow-compilation.html" class="ocsimore_phrasing_link">Compilation</a></h3><h3><a href="/eliom/6.2/manual/workflow-configuration.html" class="ocsimore_phrasing_link">Configuration &amp; running</a></h3><h3><a href="/eliom/6.2/manual/scalability.html" class="ocsimore_phrasing_link">Scalability</a></h3><h2>Syntax</h2><h3><a href="/eliom/6.2/manual/ppx-syntax.html" class="ocsimore_phrasing_link">PPX-based syntax</a></h3><h3><a href="/eliom/6.2/manual/clientserver-language.html" class="ocsimore_phrasing_link">Camlp4-based syntax</a></h3><h3><a href="/eliom/6.2/manual/ppx-migration.html" class="ocsimore_phrasing_link">Migration to PPX</a></h3><h1>Server API</h1><h2><a href="/eliom/6.2/api/server/Eliom_lib.html" class="ocsimore_phrasing_link">Eliom_lib</a></h2><h2><a href="/eliom/6.2/api/server/Eliom_client.html" class="ocsimore_phrasing_link">Eliom_client</a></h2><h2><a href="/eliom/6.2/api/server/Eliom_client_value.html" class="ocsimore_phrasing_link">Eliom_client_value</a></h2><h2><a href="/eliom/6.2/api/server/Eliom_common.html" class="ocsimore_phrasing_link">Eliom_common</a></h2><h2><a href="/eliom/6.2/api/server/Eliom_config.html" class="ocsimore_phrasing_link">Eliom_config</a></h2><h2><a href="/eliom/6.2/api/server/Eliom_request_info.html" class="ocsimore_phrasing_link">Eliom_request_info</a></h2><h2><a href="/eliom/6.2/api/server/Eliom_reference.html" class="ocsimore_phrasing_link">Eliom_reference</a></h2><h2><a href="/eliom/6.2/api/server/Eliom_state.html" class="ocsimore_phrasing_link">Eliom_state</a></h2><h2>Content and form creation</h2><h3><a href="/eliom/6.2/api/server/Eliom_content.html" class="ocsimore_phrasing_link">Eliom_content</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_content.Html.html" class="ocsimore_phrasing_link">Eliom_content.Html</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_content.Svg.html" class="ocsimore_phrasing_link">Eliom_content.Svg</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_content.Xml.html" class="ocsimore_phrasing_link">Eliom_content.Xml</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_tools.html" class="ocsimore_phrasing_link">Eliom_tools</a></h3><h2>Service creation</h2><h3><a href="/eliom/6.2/api/server/Eliom_service.html" class="ocsimore_phrasing_link">Eliom_service</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_parameter.html" class="ocsimore_phrasing_link">Eliom_parameter</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_registration.html" class="ocsimore_phrasing_link">Eliom_registration</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_registration.Html.html" class="ocsimore_phrasing_link">Eliom_registration.Html</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_registration.Action.html" class="ocsimore_phrasing_link">Eliom_registration.Action</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_registration.Ocaml.html" class="ocsimore_phrasing_link">Eliom_registration.Ocaml</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_registration.App.html" class="ocsimore_phrasing_link">Eliom_registration.App</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_registration.File.html" class="ocsimore_phrasing_link">Eliom_registration.File</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_registration.Any.html" class="ocsimore_phrasing_link">Eliom_registration.Any</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_registration.Redirection.html" class="ocsimore_phrasing_link">Eliom_registration.Redirection</a></h3><h2>Client/server communication</h2><h3><a href="/eliom/6.2/api/server/Eliom_shared.html" class="ocsimore_phrasing_link">Eliom_shared</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_notif.html" class="ocsimore_phrasing_link">Eliom_notif</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_cscache.html" class="ocsimore_phrasing_link">Eliom_cscache</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_bus.html" class="ocsimore_phrasing_link">Eliom_bus</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_comet.html" class="ocsimore_phrasing_link">Eliom_comet</a></h3><h3><a href="/eliom/6.2/api/server/Eliom_react.html" class="ocsimore_phrasing_link">Eliom_react</a></h3><h2>Index</h2><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/index_types.html">Index of types</a></span></h3><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/index_exceptions.html">Index of exceptions</a></span></h3><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/index_values.html">Index of values</a></span></h3><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/index_modules.html">Index of modules</a></span></h3><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/index_module_types.html">Index of module types</a></span></h3><h1>Ocamlbuild plugin</h1><h2><a href="/eliom/6.2/api/ocamlbuild/Ocamlbuild_eliom.html" class="ocsimore_phrasing_link">Ocamlbuild_eliom</a></h2><h1>Client API</h1><h2><a href="/eliom/6.2/api/client/Eliom_lib.html" class="ocsimore_phrasing_link">Eliom_lib</a></h2><h2><a href="/eliom/6.2/api/client/Eliom_client.html" class="ocsimore_phrasing_link">Eliom_client</a></h2><h2><a href="/eliom/6.2/api/client/Eliom_client_value.html" class="ocsimore_phrasing_link">Eliom_client_value</a></h2><h2>Content and form creation</h2><h3><a href="/eliom/6.2/api/client/Eliom_content.Html.html" class="ocsimore_phrasing_link">Eliom_content.Html</a></h3><h3><a href="/eliom/6.2/api/client/Eliom_content.Svg.html" class="ocsimore_phrasing_link">Eliom_content.Svg</a></h3><h3><a href="/eliom/6.2/api/client/Eliom_content.Xml.html" class="ocsimore_phrasing_link">Eliom_content.Xml</a></h3><h2>Client/server communication</h2><h3><a href="/eliom/6.2/api/client/Eliom_service.html" class="ocsimore_phrasing_link">Eliom_service</a></h3><h3><a href="/eliom/6.2/api/client/Eliom_shared.html" class="ocsimore_phrasing_link">Eliom_shared</a></h3><h3><a href="/eliom/6.2/api/client/Eliom_cscache.html" class="ocsimore_phrasing_link">Eliom_cscache</a></h3><h3><a href="/eliom/6.2/api/client/Eliom_bus.html" class="ocsimore_phrasing_link">Eliom_bus</a></h3><h3><a href="/eliom/6.2/api/client/Eliom_comet.html" class="ocsimore_phrasing_link">Eliom_comet</a></h3><h3><a href="/eliom/6.2/api/client/Eliom_react.html" class="ocsimore_phrasing_link">Eliom_react</a></h3><h2>Index</h2><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/index_types.html">Index of types</a></span></h3><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/index_exceptions.html">Index of exceptions</a></span></h3><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/index_values.html">Index of values</a></span></h3><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/index_modules.html">Index of modules</a></span></h3><h3> <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/index_module_types.html">Index of module types</a></span></h3><h1>Ppx syntax</h1><h2><a href="/eliom/6.2/api/ppx/Ppx_eliom.html" class="ocsimore_phrasing_link">Ppx_eliom</a></h2><h1 id="communication"> Communication between the client and the server <a class="backref" href="#communication">&#182;</a></h1><nav id="overview" class="ocsimore_outline"><header><p><strong>Table of contents</strong></p></header></nav><script>
//<![CDATA[
outline([0,-515484383,0,[0,2],[0,"nav",[0,"aside",0]],"overview",0])
//]]>
</script><p>Besides injections and client values, as described in the
documentation of our
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/manual/ppx-syntax.html">PPX syntax extension</a></span>,
there are multiple ways for the client and the server to exchange values.
</p><h2 id="rpc"> Remote Procedure Calls <a class="backref" href="#rpc">&#182;</a></h2><p>Eliom provides an easy way to call server functions from the client:
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_client.html#TYPEserver_function">Eliom_client.​server_function</a></span>.
</p><p>A function <span class="monospace">'a -&gt; 'b Lwt.t</span> can be wrapped on the server by
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_client.html#VALserver_function">Eliom_client.​server_function</a></span>.
When the result is injected to the client, it appears as a plain function
<span class="teletype">'a -&gt; 'b Lwt</span>.
</p><p>It is necessary to provide an instance of
<span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/2.8.4/api/Deriving_Json.html">Deriving_Json</a></span>
for the argument type, to safely send the argument from the client to
the server.
</p><p>Every call to <span class="teletype">server_function</span> creates a new pathless POST
service. If you want to use a server function in multiple places, it
is thus advisable to only apply <span class="teletype">server_function</span> once and bind it
to an identifier.
</p><p>Example:
</p><pre class=""><code class="language-ocaml translatable">let%server log str = Lwt_io.write_line Lwt_io.stdout str

let%client log =
  ~%(Eliom_client.server_function [%derive.json: string] log)

let%client () =
  Eliom_client.onload
    (* NB The service underlying the server_function isn't available
       on the client before loading the page. *)
    (fun () -&gt;
       Lwt.async
         (fun () -&gt; log &quot;Hello from the client to the server!&quot;))</code></pre><p>Exceptions raised in the server-side function cannot be handled
directly on the client; it is impossible to marshal them in OCaml to
send them to the client. Instead, if an exception is raised in the
server function, the function application fails (in Lwt) on the client
with the exception <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/Eliom_client_value.html#EXCEPTIONException_on_server">Eliom_client_value.​Exception_on_server</a></span> whose argument describes the original
exception (according to <span class="teletype">Printexc.to_string</span>).
</p><h2 id="notifs"> Notifications from server to clients <a class="backref" href="#notifs">&#182;</a></h2><p>Module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_notif.html">Eliom_notif</a></span>
makes it possible for a server to send values to clients with a very simple
interface. See later in this chapter for lower level server push notifications.
</p><p>Create a module for each kind of notifications you want using module
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_notif.Simple.html">Eliom_notif.​Simple</a></span>.
For example the notifications of new messages in a chat.
</p><p>Each client process must register on each resource for which it wants
to receive the the notifications
(each chat currently opened, in our example), using function
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_notif.Simple.html#VALlisten">Eliom_notif.​Simple.​listen</a></span>.
</p><p>Then the server can send a notification to all the clients listening
on a resource, using function
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_notif.Simple.html#VALnotify">Eliom_notif.​Simple.​notify</a></span>.
</p><p>More details in the API documentation of module
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_notif.html">Eliom_notif</a></span>.
</p><h2> Services returning OCaml values</h2><p>Server functions are implemented using special services that take and
return OCaml values. In this section we will see how to define
services returning OCaml data. This is a lower level interface to
do remote procedure calls, and you won't probably need this for
basic use.
</p><p>These services are registered using
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_registration.Ocaml.html">Eliom_registration.​Ocaml</a></span>
and can be called using
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/Eliom_client.html#VALcall_ocaml_service">Eliom_client.​call_ocaml_service</a></span>.
</p><p>Such services cannot be visited by the browser as Web pages. You
usually want POST pathless services for this use case. This
corresponds to remote function calls, that are typically handled by
pathless POST services.
</p><p>Example of use:
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content

let pi_service =
  Eliom_registration.Ocaml.create
    ~path:Eliom_service.No_path
    ~meth:(Eliom_service.Post (Eliom_parameter.unit, Eliom_parameter.unit))
    (fun () () -&gt; Lwt.return 3.1415926535)

let _ =
  My_appl.create
    ~path:(Eliom_service.Path [&quot;pi&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    (fun () () -&gt;
       ignore [%client
         (Lwt.ignore_result (
            let%lwt pi =
              Eliom_client.call_ocaml_service ~service:~%pi_service () ()
            in
            Lwt.return (
              Dom_html.window##alert
                (Js.string (&quot;pi = &quot;^ string_of_float pi))))
          : unit)
       ];
       Lwt.return
         Html.D.(
           html
             (head (title (pcdata &quot;pi&quot;)) [])
             (body [])))</code></pre><p>Since the client-side representation of values differs from the
server-side representation, there are restrictions on what can be
sent. The restrictions are the same as for the <span class="teletype">~%variable</span>
mechanism. (See <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/manual/clientserver-wrapping.html">chapter
Wrapping</a></span>.)
</p><h2 id="client_sending_data">Send OCaml values to services <a class="backref" href="#client_sending_data">&#182;</a></h2><p>The client can send OCaml values as parameters to services.
To do that, declare the expected parameter type using
<span class="teletype">Eliom_parameter.ocaml</span> (see
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_parameter_sigs.S.html#VALocaml">Eliom_parameter_sigs.​S.​ocaml</a></span>).
</p><p>This is used for example to implement server functions.
</p><p>Since the server cannot trust the client to send correctly-formed
data, Eliom is not using the standard OCaml marshalling
mechanism. (The server needs to be able to check that the value is of
the expected type.) For this reason, you must declare the types of the
data you want to be able to send to the server using our
<span class="teletype">ppx_deriving</span> syntax extension:
</p><pre class=""><code class="language-ocaml translatable">[%%shared
  type some_type = (int * string list) [@@deriving json]
  type another_type =
    | A of some_type
    | B of another_type
    [@@deriving json]
]</code></pre><p>This type can now be used as a parameter for a service:
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content

let s =
  My_appl.create
    ~path:(Eliom_service.Path [&quot;s1&quot;])
    ~meth:
      (Eliom_service.Get
         (Eliom_parameter.ocaml &quot;param&quot; [%derive.json: another_type]))
    (fun v () -&gt;
       Lwt.return Html.D.(
         html
           (head (title (pcdata &quot;title&quot;)) [])
           (body [
              match v with
              | A _ -&gt; pcdata &quot;A&quot;
              | B _ -&gt; pcdata &quot;B&quot;
            ])))

let _ =
  My_appl.create
    ~path:(Eliom_service.Path [&quot;s2&quot;])
    ~meth:(Eliom_service.Get Eliom_parameter.unit)
    (fun () () -&gt;
       Lwt.return Html.D.(
         html
           (head (title (pcdata &quot;title&quot;)) [])
           (body
              [p ~a:[a_onclick
                       [%client
                         (fun _ -&gt;
                            Lwt.async (fun () -&gt;
                              Eliom_client.change_page ~service:~%s
                                (A (1, [&quot;s&quot;])) ()))
                       ]]
                 [pcdata &quot;Click to send Ocaml data&quot;]])))</code></pre><p>It works for the datatypes you define, and the data types from OCaml's
standard library. For types defined in third-party libraries, have a
look at deriving's
<a href="http://code.google.com/p/deriving/wiki/Introduction" class="ocsimore_phrasing_link">documentation</a>
and Js_of_ocaml's <span><a class="ocsforge_doclink_js_of_ocaml" href="/js_of_ocaml/2.8.4/api/Deriving_Json.html">Deriving_Json</a></span>.
</p><h2> Server sending data (lower level interfaces for notifications)</h2><p>Module <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_notif.html">Eliom_notif</a></span>
described above is implemented on top of a mechanism to allow the
server to send data to a client.
We call this mechanism <em>Comet</em>. The same idea is also known as
<em>HTTP push</em>.
</p><p>The simple low-level version above which all other following mechanisms are
implemented is provided in the <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_comet.Channel.html">Eliom_comet.​Channel</a></span>
module.
</p><p>Comet defines channels which can transfer data. A channel is created
using an Lwt stream. It is a kind of cooperative lazy list.
</p><p>The two main methods to create a stream are through the functions
<span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_stream.html#VALfrom">Lwt_stream.​from</a></span> and
<span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_stream.html#VALcreate">Lwt_stream.​create</a></span>.
</p><pre class=""><code class="language-ocaml translatable">val from : (unit -&gt; 'a option Lwt.t) -&gt; 'a t
val create : unit -&gt; 'a t * ('a option -&gt; unit)</code></pre><p>Function <span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_stream.html#VALfrom">Lwt_stream.​from</a></span> makes possible
to create a stream where a new value is added each time a function returns.
Function <span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_stream.html#VALcreate">Lwt_stream.​create</a></span>
returns a stream and a function to push new values to the stream.
</p><p>On client-side, the type
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/Eliom_comet.Channel.html#TYPEt">Eliom_comet.​Channel.​t</a></span>
is just an Lwt stream <span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_stream.html#TYPEt">Lwt_stream.​t</a></span>.
</p><p>There are 3 kinds of channels, depending on how you want to send data.
</p><ul><li> Channels created with
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_comet.Channel.html#VALcreate">Eliom_comet.​Channel.​create</a></span>
have a buffer with a limited size. Message are read from the stream as
soon as they are available, i.e. for stream created with
<span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_stream.html#VALfrom">Lwt_stream.​from</a></span>, that means that the
function is called another time as soon as the previous one terminates.
For stream created with <span><a class="ocsforge_doclink_lwt" href="/lwt/3.1.0/api/Lwt_stream.html#VALcreate">Lwt_stream.​create</a></span>,
this is as soon as they are pushed. If the client misses too many
messages (more than the size of the buffer) it will receive an exception
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/Eliom_comet.html#EXCEPTIONChannel_full">Eliom_comet.​Channel_full</a></span>
when reading data from the stream.
</li></ul><ul><li> Channels created with
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_comet.Channel.html#VALcreate_newest">Eliom_comet.​Channel.​create_newest</a></span> have no buffering
and can lose messages, but the client will always receive the last value:
For instance, if many messages are sent in a short time,
the client may receive only the last one. Those channels never raise
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/Eliom_comet.html#EXCEPTIONChannel_full">Eliom_comet.​Channel_full</a></span>.
</li></ul><ul><li> Channels created with <span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_comet.Channel.html#VALcreate_unlimited">Eliom_comet.​Channel.​create_unlimited</a></span>
consume data on the stream only when their is a request from the client.
</li></ul><p>Channels can be closed on client side by cancelling a thread waiting
for data on it.
</p><p>Like services, channels have a scope (only site or client process).
The constraints vary with respect to the scope you choose:
</p><ul><li> Channels created with scope
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_common.html#VALsite_scope">Eliom_common.​site_scope</a></span> or
using
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_comet.Channel.html#VALcreate_newest">Eliom_comet.​Channel.​create_newest</a></span>
are stateless channels: the memory consumption does not depend on
the number of users requesting data on it. When the channels are not
reachable from the server code, they are garbage-collected and closed.
Named stateless channels can be accessed from
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/manual/clientserver-applications.html#cors_channels">other servers</a></span>.
</li></ul><ul><li> Channels created with scope
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_common.html#VALdefault_process_scope">Eliom_common.​default_process_scope</a></span>
must be created inside a service handler. They
are assigned to a particular client process. Different channels
created with the same stream do not share memory. They are closed
when requested or when the client process is closed. It is possible
to know when a client stop requesting data on those channels using
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_comet.Channel.html#VALwait_timeout">Eliom_comet.​Channel.​wait_timeout</a></span>.
Be careful about memory consumption when using
client process channels.
</li></ul><h3> Comet configuration</h3><p>The server can push data to a client only when the client has an open
HTTP connection waiting for a response. As of now, a comet request can
only last at most 10 seconds. After that, the client can either do a
new request or stale for some time: this is the activity
behavior. This can be configured on client-side, using the functions from
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/Eliom_comet.Configuration.html">Eliom_comet.​Configuration</a></span>
</p><p>For instance, if you receive data which doesn't need frequent
updates, you can set the time between different requests to a high value,
and stop requesting data as soon as the browser loses the focus.
</p><pre class=""><code class="language-ocaml translatable">open Eliom_comet.Configuration
let slow_c = new_configuration () in
set_active_until_timeout slow_c false;
set_time_between_request slow_c 60.</code></pre><p>If you need more reactivity for a few seconds, do:
</p><pre class=""><code class="language-ocaml translatable">open Eliom_comet.Configuration
let fast_c = new_configuration () in
set_set_always_active fast_c true;
set_set_time_between_request fast_c 0.;
ignore (Lwt_js.sleep 10. &gt;|= (fun () -&gt; drop_configuration fast_c))</code></pre><p>The original setting will be reset after the drop.
</p><h2> Reactive values</h2><p>A common usage of comet is for the server to update a value available
on client side. A convenient way to implement this is to use reactive
programming. Eliom provides a reactive interface for channels, using
the <a href="http://erratique.ch/software/react" class="ocsimore_phrasing_link"> react</a>. library.
</p><p>To share a React event or signal with the client, use functions
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_react.Down.html#VALof_react">Eliom_react.​Down.​of_react</a></span> or
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_react.S.Down.html#VALof_react">Eliom_react.​S.​Down.​of_react</a></span>
</p><p>On client-side, the value returned by those functions is directly
a React event or signal.
</p><p>The opposite is also available using
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_react.Up.html#VALcreate">Eliom_react.​Up.​create</a></span>.
</p><p>Since this is implemented using Comet, tuning Comet configuration will
also affect the behaviour of shared react variables.
</p><h2> Client-Server shared bus</h2><p>It is sometimes useful to have a bidirectional channel shared between
multiple clients.
This is the purpose of buses. Those are created using
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_bus.html#VALcreate">Eliom_bus.​create</a></span>.
Since the server will also receive data on the bus, the description of
the type (using <span class="teletype">deriving</span>) is needed to create a bus.
</p><p>Like comet channels, the behaviour of buses can be tuned using the module
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/client/Eliom_comet.Configuration.html">Eliom_comet.​Configuration</a></span>.
There are additionnal configuration options available for buses to tune
the client-side buffering.
</p><h2 id="cors_channels"> Another Server sending data (Comet on another server) <a class="backref" href="#cors_channels">&#182;</a></h2><p>It is possible to access a named stateless channel created on another
server. It has to be declared using
<span><a class="ocsforge_doclink_eliom" href="/eliom/6.2/api/server/Eliom_comet.Channel.html#VALexternal_channel">Eliom_comet.​Channel.​external_channel</a></span>.
The declaration of the channel must match exactly the creation. The
server generating the page and the server that created the channel
must run exactly the same version of Eliom. By default a browser can't
do requests to a different server, to allow that the server serving
the channel must allow Cross-Origin Resource Sharing using the
<span><a class="ocsforge_doclink_ocsigenserver" href="/ocsigenserver/2.8/manual/cors.html">CORS Ocsigenserver
extension</a></span>.
</p></body></html>
